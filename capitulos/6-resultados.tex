\chapter{Resultados obtidos}
\label{cap-resultados}

Este capítulo aborda sobre os resultados encontrados, a patir da proposta de 
definição e preparação dos estudos, como dito no capítulo \ref{cap-metodologia}
as aplicações escolhidas como piloto, para terem sua instalação automatizada foram Owncloud e
Wordpress como visto em na seção \label{subsection:validacao}
, seguindo a escolha da ferramenta Shak como arquitetura inicial. Todo 
o trabalho foi organizado na ferramenta Gitlab
no projeto Shak disponível no endereço \href{https://gitlab.com/Shak/Shak/} nele
contém todo o código fonte disponível.
 
\section{Wordpress}
\label{sub:wordpress}

De acordo com a documentação oficial \cite{wordpress} Wordpress é uma plataforma
semântica de vanguarda para publicação pessoal, com foco na estética, nos
Padrões Web e na usabilidade e ao mesmo tempo é um software livre. Wordpress é
um dos maiores software de publicação de conteúdo, sendo hoje a maior
plataforma de Gerenciamento de Conteúdo do mundo, com quase 70\% do mercado. O
wordpress foi a primeira ferramenta escolhida para automatizar a instalação, partindo
dessa decisão deu início a construção da solução.

Primeiramente foram seguido os procedimentos para construção da solução definidos na seção \ref{section:construcao}, é
necessário definir as fases e procedimentos para a implantação automatizada,
seguindo as fases que compõem o processo de implantação de aplicações e de acordo
com \cite{omg2006}, e isso será o que o Shak automatizará, cada fase desse processo
 será tratada como uma subseção. No wordpress as fases e procedimentos são:

\begin{itemize}
  \item  \textbf{Planejamento}
  \item  \textbf{Preparação e Instalação de Pacotes}
  \item  \textbf{Configuração}
  \item  \textbf{Configuração de múltiplas instâncias}
  \item  \textbf{Inicialização}
\end{itemize}


\subsection{Planejamento}

O planejamento da implantação é uma fase para identificar os componentes
necessários na implantação da aplicação. Definir quais são as dependências mínimas
para o funcionamento de uma aplicação, tais como: banco de dados, pacotes
pré-instalados e aplicações pré-configuradas. Para o wordpress foram escolhidas:

\begin{itemize}
   \item \textbf{Pacote wordpress para o Debian:} Pacote Debian com o wordpress.
   \item \textbf{Pacote Nginx para o Debian:} Pacote Debian com o Nginx.
   \item \textbf{Pacote mysql para o Debian:} Pacote Debian com o banco de dados mysql
   que será usado pelo wordpress.
   \item \textbf{Arquivos de configuração:} Criação dos arquivos de configuração
   necessários para configurar o wordpress, o servidor web Nginx e o banco de dados
   mysql.
\end{itemize}

A instalação e execução desses recursos serão feitas nas fases seguintes.

\subsection{Preparação e Instalação de Pacotes}
\label{wordpress:preparacao}

São os procedimentos necessários para preparar o ambiente alvo para que o wordpress
possa ser executado, isso envolve configuração do sistema operacional, instalação
e configuração de dependências necessárias, e a transferência do componente
para o servidor onde ele será executado.

Para o funcionamento correto do wordpress é necessário a instalação do php5, além
disso também é necessário que algum servidor web, na arquitetura do Shak o servidor
web padrão é o Nginx, e o banco de dados mysql.

Para solução desse procedimento bastou apenas instalar os pacotes php5-fpm, o pacote
do banco de dados mysql e o pacote nginx, além disso habilitar o serviço do
php5-fpm, todos esses passos são feitos antes da instalação do wordpress,
pois por default se ele não encontrar essas dependências ele instala o servidor
apache2.

Para executar essas instalações é preciso criar uma receita no livro de receitas
do wordpress, primeiramente é necessário criar o próprio livro de receitas no Shak,
para isso existe o comando rake cookbook que cria a estrutura básica
de um livro de receitas que deve ser usado pelo Chef, como por exemplo:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de criação de estrutura básica de livro de receitas do wordpress com shak}]
  rake cookbook
  Cookbook name: wordpress
  knife cookbook create wordpress -o cookbooks/
  ** Creating cookbook foo in /home/thiago/Shak/cookbooks
  ** Creating README for cookbook: wordpress
  ** Creating CHANGELOG for cookbook: wordpress
  ** Creating metadata for cookbook: wordpress
\end{lstlisting}

Assim com a estrutura inicial, é possível declarar as dependências do wordpress
dentro do arquivo default.rb dentro da pasta recipes. Nesse arquivo é aonde
será declarado os pacotes que devem ser instalados, os arquivos de configuração,
os serviços que precisar executar, as pastas, permissões de usuários, etc. Um exemplo
de como declarar pacotes e serviços dentro de uma receita Chef é:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de criação de serviço do mysql com o chef}]
  package "mysql-server"
  service "mysql" do
    action :start
  end
\end{lstlisting}


\subsection{Configuração}
\label{wordpress:preparacao}

Como levantado no planejamento é necessário a edição de arquivos de configuração
do wordpress, arquivos de configuração do banco de dados e arquivo de configuração
do nginx.

O primeiro arquivo de configuração é o config.php, é nesse arquivo de
configuração onde ficam as informações de banco de dados como nome do banco de dados,
login do usuário do banco de dados, senha, o host do banco de dados e o diretório
onde irá ficar os temas, galeria de mídias e plugins de cada instância do wordpress.
Por padrão ele deve ficar no diretório /etc/wordpress/ e seu nome deve conter
a seguinte estrutura: config-nomehost.php, onde o nomehost deve ser o hostname
desejado. O segundo arquivo é o database.sql que é um pequeno script sql que
cria o banco de dados do Wordpress e dá os privilégios ao usuário desejado. Por fim
o arquivo de configuração do Nginx configuração do servidor web.

Esses arquivos de configuração serão criados dentro da pasta template, com o conteúdo
desejado dos arquivos de configuração, seguindo a mesma estrutura
inicial que foi criada em \ref{wordpress:preparacao}, e a ação de criação é
declarada dentro do arquivo default.rb, de forma semelhante como foi feito com
a declaração dos pacotes. Um exemplo de como gerenciar templates em uma receita Chef
é:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de criação de templates com o chef}]
  template "text\_file.txt" do
  source "text\_file.txt"
  mode "0755"
  owner "root"
  group "root"
\end{lstlisting}

\subsection{Múltiplas Instâncias}

O uso de múltiplas instâncias do wordpress pode ser feito de duas maneiras, e servem
para que o usuário possa ter várias instâncias de wordpress no mesmo servidor, de
acordo com a documentação do wordpress é possível ter múltiplos sites e múltiplas
instâncias, no caso do Shak é desejado que seja múltiplas instâncias, a partir da
repetição da instalação. O wordpress recomenda que se for necessário o uso de múltiplas
instâncias é necessário realmente instalar cada Wordpress, um por vez.

A arquitetura para isso não é muito complicada, porém algumas pastas do sistema
precisam ser divididas, ou seja, uma para cada aplicação, essa pasta é a pasta wp-content
que é a pasta aonde fica os uploads, os temas, os plugins e etc, portanto para não
existir conflito entre as instâncias essas pastas devem estar devidamente separadas
com seus caminhos referenciados em cada arquivo config.php, o arquivo config.php também
deve ser único para cada instância. Além disso também é preciso que cada instância
tenha seu banco de dados, para evitar novamente os conflitos. Para
solucionar esse problema o Shak possui um recurso interessante onde cada aplicação
possui um atributo id, que é um atributo único para cada instância executada pelo
Shak, com isso é possível criar pastas personalizadas com o id da aplicação e também
bancos de dados específicos e arquivos config.php específicos.

Por fim basta que seja criado um arquivo de configuração Nginx para cada aplicação,
como visto no capitulo \ref{cap-referencial} todo arquivo de configuração
do Nginx possui um bloco server, e cada bloco server equivale a um virtual hosting,
por isso as aplicações serão também independentes a nível de servidor web sendo assim
possível o acesso entre elas separadamente.

\subsection{Inicialização}

Após a construção da receita do wordpress é necessário testar a receita construída,
para isso o Shak precisa de duas informações importantes, a primeira é a aplicação
que será instalada, e segunda o hostname destino. Como é um ambiente de desenvolvimento
não é preciso configurar um ip ou configurar um DNS, é preciso apenas adicionar o
hostname desejado no arquivo /etc/hosts. Assim mesmo que esteja na sua máquina local
é possível acessar um endereço mais familiar em seu navegador. Um exemplo da execução
da instalação via Shak é:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de exexução de instalação do wordpress com shak}]
Shak install wordpress hostname=wordpress.dev
\end{lstlisting}

E assim o Chef inicia o processo de instalação dos pacotes, criação dos arquivos
de configuração, incia os serviços desejados, e ao fim do procedimento a aplicação
já estará pronta para uso no hostname escolhido.

\section{Owncloud}
\label{sub:owncloud}

De acordo com a documentação oficial \cite{owncloud} Owncloud é uma ferramenta
para compartilhamento de arquivos, é um software livre em que é possível compartilhar
um ou mais arquivos e pastas do seu computador na nuvem, e sincronizá-los com o seu
servidor Owncloud, esses arquivos são imediatamente sincronizados com o servidor
e disponibilizados para outros dispositivos que utilizam o ambiente de trabalho
Owncloud ou app Android ou app IOS.

Também foram seguidos os mesmos passos feitos em \ref{sub:wordpress}, primeiramente
foram seguidos os procedimentos para construção da solução definidos em \ref{section:construcao},
definindo as fases e procedimentos para a implantação automatizada, seguindo as
fases que compõem o processo de implantação de aplicações e de acordo com \cite{omg2006},
cada fase desse processo também será tratado como uma subseção. No Owncloud as
fases e procedimentos são:

\begin{itemize}
  \item  \textbf{Planejamento}
  \item  \textbf{Preparação e Instalação de Pacotes}
  \item  \textbf{Configuração}
  \item  \textbf{Configuração de múltiplas instâncias}
  \item  \textbf{Inicialização}
\end{itemize}

\subsection{Planejamento}

Seguindo a mesma linha do wordpress, é necessário definir quais são as dependências
mínimas para o funcionamento do Owncloud tais como: banco de dados, pacotes
pré-instalados e aplicações pré-configuradas. Para o Owncloud foram escolhidas:

\begin{itemize}
   \item \textbf{Pacote Owncloud para o Debian:} Pacote Debian com o Owncloud.
   \item \textbf{Pacote Nginx para o Debian:} Pacote Debian com o nginx.
   \item \textbf{Pacote Postgresql para o Debian:} Pacote Debian com o banco de dados postgresql
   que será usado pelo Owncloud.
   \item \textbf{Arquivos de configuração:} Criação dos arquivos de configuração
   necessários para configurar o Owncloud, o servidor web Nginx e o banco de dados
   postgresql.
\end{itemize}

A diferença da escolha do banco de dados em relação ao wordpress é poder aumentar
o suporte a diferentes bancos de dados, na documentação do wordpress é recomendado
o uso do banco de dados mysql, porém no Owncloud fica a escolha do desenvolvedor.
A escolha do postgresql vêm com a possibilidade de trabalhar com dois bancos de
dados diferentes, aumentando o suporte do Shak, assim quando existirem aplicações
que suportam apenas o postgresql o Shak já terá uma estrutura básica pronta.
A instalação e execução desses recursos serão feitas nas fases seguintes.

\subsection{Preparação e Instalação de Pacotes}

Para o funcionamento correto do Owncloud é necessário a instalação do php5, além
disso também é necessário que algum servidor web, na arquitetura do Shak o servidor
web padrão é o Nginx, e o banco de dados Postgresql.

Para solução desse procedimento foi necessário instalar os pacotes php5-fpm, o banco
de dados postgresql e o pacote nginx, além disso habilitar o serviço do php5-fpm,
também foi necessário instalar o pacote php5-pgsql que é um módulo para
conexões de banco de dados postgresql, necessário para o funcionamento de
aplicações php com o postgresql.

Para executar essas instalações é preciso criar uma receita no livro de receitas
do owncloud, bastando executar novamente o comando rake cookbook que cria a estrutura básica
de um livro de receitas que deve ser usado pelo Chef, como por exemplo:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de criação de estrutura básica de livro de receitas do owncloud com shak}]
  rake cookbook
  Cookbook name: owncloud
  knife cookbook create owncloud -o cookbooks/
  ** Creating cookbook foo in /home/thiago/Shak/cookbooks
  ** Creating README for cookbook: owncloud
  ** Creating CHANGELOG for cookbook: owncloud
  ** Creating metadata for cookbook: owncloud
\end{lstlisting}

Assim com a estrutura inicial, é possível declarar as dependências do owncloud
dentro do arquivo default.rb dentro da pasta recipes. Nesse arquivo é aonde
será declarado os pacotes que devem ser instalados, os arquivos de configuração,
os serviços que precisar executar, as pastas, permissões de usuários, etc. Um exemplo
de como declarar pacotes e serviços dentro de uma receita Chef é:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de como habilitar serviço do postgresql com chef}]
  package "postgresql"
  service "postgresql" do
    action :start
  end
\end{lstlisting}

\subsection{Configuração}

Como levantado no planejamento é necessário a edição de arquivos de configuração
do owncloud, arquivos de configuração do banco de dados e arquivo de configuração
do Nginx.

O primeiro arquivo de configuração é o autoconfig.php, é nesse arquivo de
configuração onde ficam as informações de banco de dados como nome do banco de dados,
login do usuário do banco de dados, senha, o host do banco de dados e o diretório
onde irá ficar os arquivos de configuração do owncloud, além disso o login e senha
do administrador, isso é necessário apenas para o primeiro acesso, ou seja, o usuário
fará o login automaticamente quando o owncloud terminar a instalação, após isso
a recomendação é trocar a senha do administrador.

Além disso é necessário criar a pasta de conteúdos públicos do owncloud, que por
padrão devem ficar em /etc/owncloud. O segundo arquivo é o postgresql-conf.sql
que é um pequeno script sql que cria o banco de dados do owncloud e dá os
privilégios ao usuário desejado. Por fim o arquivo de configuração do Nginx
configuração do servidor web.

\subsection{Múltiplas Instâncias}

Diferentemente do wordpress o owncloud não suporta múltiplas instâncias, porém isso
não foi um impeditivo na execução do trabalho, com uma busca encontrou-se uma discussão no repositório
oficial do owncloud relacionado a implementação dessa funcionalidade, a discussão está
disponibilizada em \href{https://github.com/owncloud/core/pull/16424}, nela existia
uma proposta de solução ao fato de não existir a opção de múltiplas instâncias. O
resultado desta discussão foi que os desenvolvedores do owncloud não acharam relevante
a funcionalidade, mas que caso o desenvolvedor ache necessário ele poderia fazer essa
alteração diretamente no código fonte.

Porém manter isso no Shak seria enviável, uma solução a esse problema seria enviar
uma contribuição ao pacote do owncloud no Debian, onde assim a contribuição feita
poderia ser facilmente utilizada por mais pessoas que queiram essa funcionalidade,
bastando utilizar a versão disponibilizada nos servidores do Debian. Com isso, foi
feito a contribuição que adicionaria a funcionalidade de múltiplas instâncias para
o owncloud e enviado ao mantenedor do pacote do owncloud no Debian,
a discussão está disponível em \href{https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=789726},
a contribuição foi bem vista pelo mantenedor do pacote, e será incorporada na nova
versão do owncloud no Debian.

Em paralelo ao processo da contribuição estar disponível no novo pacote Debian,
foi necessário utilizar apenas instâncias únicas do owncloud, porém também foi
adicionado na receita do owncloud o suporte a múltiplas instâncias, portanto
assim que o owncloud suportar múltiplas instâncias via pacote Debian, será possível
também criar múltiplas instâncias do owncloud.

A solução feita na receita do owncloud foi baseada na contribuição enviada, portanto
os testes foram feitos gerando um novo pacote Debian do owncloud porém incorporando
a contribuição feita. Os procedimentos feitos para suportar múltiplas instâncias
no owncloud são bem semelhantes aos do wordpress, criando um diretório de dados
para cada aplicação, um arquivo de configuração para cada aplicação e um banco de
dados para cada aplicação. Seguindo também a mesma abordagem do wordpress também
será criado um virtual hosting para cada instância do owncloud.

\subsection{Inicialização}

Após a construção da receita do owncloud é necessário testar a receita construída,
para isso o Shak precisa de duas informações importantes, a primeira é a aplicação
que será instalada, e segunda o hostname destino, para executar a instalação
do owncloud basta:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de execução de instalação do owncloud com shak}]
shak install owncloud hostname=owncloud.dev
\end{lstlisting}

E assim o Chef inicia o processo de instalação dos pacotes, criação dos arquivos
de configuração, incia os serviços desejados, e ao fim do procedimento a aplicação
já estará pronta para uso no hostname escolhido.


\section{Servidor de e-mail}
\label{sub:e-mail}

Todas as outras aplicações anteriores utilizam o protocolo
HTTP na camada de aplicação, agora com o servidor de e-mail será trabalhado um
protocolo diferente, como visto no capítulo \ref{cap-referencial}
de acordo \cite{kurose2010redes} a camada de aplicação é aonde residem as aplicações
de rede e seus protocolos, dentre eles o protocolo SMTP que provê mensagens de correio
eletrônico.

Servidores de e-mail formam a infraestrutura do e-mail, sendo o SMTP o protocolo
mais importante pois é o responsável por transferir as mensagens de servidores
de e-mail remetentes para servidores de e-mail destinatários, ou seja, transferindo
arquivos (as mensagens de e-mail) de um servidor para o outro. Porém o protocolo
SMTP é um protocolo do tipo de envio de informações, diferente do protocolo HTTP
que é um protocolo que recupera informações, o que acarretaria um problema em que
o usuário não conseguiria recuperar suas informações como e-mails recebidos, já
que o SMTP apenas envia informações.

Para solucionar esse problema existem os protocolos de acesso a servidores de
e-mail, que recuperam as informações do servidor de e-mail até ao usuário final.
Como visto no capítulo \ref{cap-referencial} existem protocolos de acesso ao correio
como POP3, IMAP ou usar até mesmo o protocolo HTTP servindo de protocolo para recuperar
informações.

Dando continuidade na construção da solução, tanto owncloud como wordpress
possuem funcionalidades que dependem de serviços de e-mail funcionando, portanto
é necessário uma configuração mínima de e-mail para que funcione tais funcionalidades.
Portanto a construção de um servidor de e-mail possui bastante relevância pois
assim qualquer aplicação que precisar de um servidor de e-mail já poderá utilizar
o servidor de e-mail que o Shak fornece.

Para a construção do servidor de e-mail também foram seguidos os mesmos passos
feitos em \ref{sub:wordpress} e \ref{sub:owncloud}, primeiramente foram seguidos os
procedimentos para construção da solução definidos em \ref{section:construcao},
definindo as fases e procedimentos para a implantação automatizada, seguindo as
fases que compõem o processo de implantação de aplicações e de acordo com \cite{omg2006},
cada fase desse processo também será tratado como uma subseção. No servidor de e-mail
as fases e procedimentos são:

 \begin{itemize}
   \item  \textbf{Planejamento}
   \item  \textbf{Preparação e Instalação de Pacotes}
   \item  \textbf{Configuração}
   \item  \textbf{Inicialização}
 \end{itemize}

\subsection{Planejamento}

Seguindo o mesmo raciocínio das aplicações anteriores, é necessário definir
quais são as dependências mínimas para o funcionamento do servidor de e-mail,
como vimos é necessário configurar um servidor que utiliza o procolo IMAP ou POP3,
também é necessário a configuração de um agente de transferência de e-mails e também
alguma ferramenta para controle de spam.

Primeiramente ficou definido que o protocolo escolhido seria o protocolo IMAP, já
que o protocolo IMAP é um protocolo online, ou seja, ele se conecta ao servidor
e realiza o download das mensagens, depois ainda  mantém a conexão para que
as alterações e mensagens novas sejam atualizadas em tempo real, diferentemente do
protocolo POP3 que é um protocolo offline, onde após o download das mensagens encerra
a conexão. Outra vantagem do IMAP em relação ao POP3 é que o IMAP mantém uma cópia
de mensagens no servidor, ideal para quem precisa acessar os e-mails de mais de um local.

O servidor IMAP escolhido foi o Dovecot que é um servidor de e-mail
IMAP, além disso dovecot é um software livre simples de configurar, requer nenhuma
administração especial e ele usa muito pouca memória \cite{dovecot}. O agente
de transferência de e-mails (MTA) escolhido foi o Postfix, que é um software
livre para envio e entrega de e-mails. Sua escolha foi feita pela facilidade de
integração com o Dovecot, Postfix é quem cuidará do método de entrega de e-mail
utilizando SMTP como protocolo de transferência de e-mails. Por fim a aplicação
que servirá como anti-spam será o Apache SpamAssassin que é uma plataforma anti-spam
que que dá aos administradores de servidor de e-mail, um filtro para classificar
 e-mails e bloquear os e-mails que julgarem como spam \cite{spam}.

\begin{itemize}
   \item \textbf{Pacote dovecot para o Debian:} Pacote Debian com o dovecot.
   \item \textbf{Pacote postfix para o Debian:} Pacote Debian com o postfix.
   \item \textbf{Pacote spamassasin para o Debian:} Pacote Debian com o spamassasin.
   \item \textbf{Arquivos de configuração:} Criação dos arquivos de configuração
   necessários para configurar o spamassasin, dovecot e postfix.
\end{itemize}

\subsection{Preparação e Instalação de Pacotes }

Para o funcionamento correto do servidor de e-mail são necessários vários pacotes
e com isso é possível separar as dependências dos pacotes necessários para cada ferramenta
escolhida para compor o servidor de e-mail. Primeiramente para o postfix são necessários
os pacotes postfix e bsd-mailx, além de habilitar o serviço do postfix, para o dovecot
é necessário instalar o pacote dovecot-imadp além de habilitar o serviço do dovecot,
para o spamassassin são necessários os pacotes spamassassin e o pacote spamc e ativar
o serviço do spamassassin.

\subsection{Configuração}

Como levantado no planejamento é necessário a edição de arquivos de configuração
de todas as ferramentas, existem arquivos de configuração para cada uma delas, inclusive
o dovecot que precisa saber que estamos utilizando o postfix como agência de transferência
de e-mails.

Primeiramente, para essa configuração específica do dovecot, foi utilizado 5 arquivos
de configuração, o primeiro é o 10-mail.conf que é um arquivo de configuração para
indicar onde será o local no qual os e-mails ficarão. O segundo arquivo é o 10-ssl.conf
que é o arquivo em que possui os caminhos do certificado ssl e da chave ssl, sendo o
certificado pode ser lido por todos e o arquivo de chave apenas para um usuário root
ou que esteja no grupo de usuários ssl-cert, a geração de chaves e de certificados serão
explicados na seção %TODO qual seção ?
. O terceiro arquivo é o arquivo
11-postfix-auth.conf, arquivo responsável por indicar o caminho do arquivo de autenticação
do postfix. O quarto arquivo é o arquivo 20-imap.conf onde será indicado o tamanho
máximo de conexões por ip permitidas no servidor. Por fim o arquivo
20-disable-imap-non-ssl.conf que permitirá que o imap utilize sempre uma conexão
segura utilizando o IMAPS (IMAP + SSL), assim bloqueando qualquer conexão ou
tentativa na porta imap comum.

Para o posfix são apenas dois arquivos de configuração, o main.cf e o master.cf,
o main.cf é aonde se configura os parâmetros mínimos de configuração, lá é aonde fica as configurações que filtram os e-mails com spamassassin e algumas configurações do SMTP, no
master.cf definimos como um programa cliente se conecta a um serviço, e qual o
programa que é executado quando um serviço é solicitado. Neste caso habilitamos
recursos como: smtpd usar TLS e autenticação, caminho dos arquivos de chave e certificados
o destino das mensagens como o host do servidor de e-mail, o smtpd utilizar o dovedcot
e rejeitar conexões não autenticadas.

Por fim a configuração do spamassasin, são necessários dois arquivos de configuração
o spamassassin que é o arquivo de configurações padrão para o spamassasin e o
local.cf que são as configurações locais. No spamassassin você habilita o spamassasin
e configura o caminho do arquivo de log, opções e habilitar a cronjob que será
executada de tempos em tempos. Já o local.cf possui um parâmetro importante, o
parâmetro required\_score é um nível de 0 a 10 em que são classificados os e-mails
como spam, por default esse valor é 5 porém se o usuário quiser aumentar o filtro
pode aumentar para valores como 6 ou 7 até chegar em um nível de confiança em que
o spamassasin cuide dos casos falsos-positivos, ou seja, e-mails que não são spam
porém foram interpretados como spam.

\subsection{Inicialização}

Após a construção da receita do servidor de e-mail é necessário testar a receita construída,
para isso o Shak precisa de duas informações importantes, a primeira é a aplicação
que será instalada, e segunda o hostname destino, para executar a instalação
do servidor de e-mail basta:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de execução de instalação do servidor de e-mailcom shak}]
Shak install e-mail hostname=owncloud.dev
\end{lstlisting}


E assim o Chef inicia o processo de instalação dos pacotes, criação dos arquivos
de configuração, incia os serviços desejados, e ao fim do procedimento a aplicação
já estará pronta para uso no hostname escolhido.

Para testar o funcionamento foram feitos dois procedimentos, o primeiro era utilizar
um cliente de e-mail para testes, o cliente de e-mail escolhido foi o mutt, utilizando
suas funções básicas de enviar e receber e-mails. O segundo passo foi realizar conexões
com o servidor de e-mail via telnet, com os seguintes comandos:

\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de teste de conexão telnet no servidor imap}]
  telnet localhost imap
  telnet localhost imaps
\end{lstlisting}

Pela configuração do servidor de e-mail não será possível abrir uma conexão telnet
em imap, porém em imaps será possível, isso serve para testar que o servidor de e-mail
está barrando as conexões que não utilizem os protocolos criptografados.


%TODO ver se no tcc 2 rola de colocar o front end e tal....
%TODO falar do protótipo de alta fidelidade, o que é, como fiz.

%\subsection{Protótipo de Front-End}
%\label{sub:prototipo}

\section{Segurança}
\label{sub:seguranca}

Na implantação das aplicações foram feitos dois procedimentos de segurança, o primeiro
é forçar as aplicações web a sempre utilizarem o protocolo HTTPS e a segunda foi forçar o
servidor de e-mail a não permitir a conexão via protocolos sem criptografia, neste
caso sendo o protocolo imap utilizando o protocolo imaps. Para que isso fosse possível
foi necessário gerar um certificado ssl, certificados ssl são necessários para
que um determinado serviço opere com suporte a conexão segura por meio de criptografia.
É de conhecimento do autor que a melhor forma é obter um certificado assinado
por uma certificadora registrada, porém inicialmente foi trabalhado apenas com certificados
auto-assinados.

Para suprir a necessidade das aplicações, cada aplicação terá um certificado para
si, além disso o servidor também terá o seu certificado auto-assinado, isso foi necessário
pois a ideia é de as aplicações possam ser instaladas em diferentes servidores, por
isso é necessário garantir garantir que cada servidor possua o seu certificado. Para adicionar
esse novo suporte ao Shak foi necessário criar uma receita Chef,
para que possa gerenciar os certificados ssl. Optou-se por utilizar a ferramenta
openssl para geração das chaves e certificados, o openssl é uma ferramenta de
implementação do Transport Layer Security (TLS) e Secure Sockets Layer (SSL),
além de ser uma biblioteca de propósito geral de criptografia \cite{openssl}.

Esse novo componente no Shak é composto basicamente do pacote openssl e da geração
de certificados auto-assinados utilizando o openssl, são gerados certificados
para cada aplicação e para o servidor, o padrão do caminho onde os certificados são
gerados é etc/ssl/certs/hostname.pem onde hostname é o endereço do servidor
e o caminho onde as chaves são geradas é etc/ssl/private/hostname.key.

Com as chaves geradas basta configurar as aplicações indicando os caminhos dos certificados
e das chaves, para forçar as aplicações web a utilizarem o HTTPS foi necessário fazer
uma configuração específica no servidor web Nginx:


\begin{lstlisting}[language=Ruby,label=dice_index,caption={Exemplo de arquivo de configuração do Nginx para aplicações web no shak}]
  server {
      server_name <%= @hostname %>;
      rewrite     \^https://\$server\_name\$request\_uri? permanent;
  }

  server {
      server_name <%= @hostname %>;

      listen 443 ssl;
      ssl_certificate       /etc/ssl/certs/<%= @hostname %>.pem;
      ssl_certificate_key   /etc/ssl/private/<%= @hostname %>.key;

      access_log            /var/log/nginx/<%= @hostname %>.access.log;
      error_log             /var/log/nginx/<%= @hostname %>.error.log;

      include /var/lib/Shak/etc/nginx/<%= @hostname %>/*.conf;
  }
\end{lstlisting}

Com isso todas as requisições serão forçadas a utilizar a porta 443 que é a porta
TCP padrão para sites que utilizam HTTP + SSL, assim as aplicações utilizarão
um protocolo mais seguro utilizando criptografia dos dados, utilizando o
certificado auto-assinado que foi gerado para o servidor específico.

\section{Protótipo da aplicação web}
\label{sub:prototipo}

Outro resultado obtido neste trabalho foi a construção de um protótipo para a interface
web da aplicação, como um dos objetivos do Shak é possuir uma interface web para que
os usuários não precisem utilizar um terminal para realizar as ações, também foi
feito um protótipo funcional, para ser aplicado no shak. O protótipo foi feito
na ferramenta chamada Pingendo, que é um software livre utilizado para construir
protótipos funcionais. Além de ter um protótipo funcional, a ferramenta Pingendo
também gera o código HTML e CSS, que pode ser aproveitado para a construção
do layout do Shak. A sugestão inicial foi feita utilizando HTML + CSS utilizando
bootstrap 3, que é um framework para criar aplicações responsivas na web. A versão
inicial está disponível em \href{https://gitlab.com/Thiagovsk/shak_frontend/tree/master}.


%TODO colocar aplicações novas que forem inseridas
